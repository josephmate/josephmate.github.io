---
layout: post
title: "32,000% CPU Utilization"
date: 2023-05-01 9:00
author: joseph
comments: true
categories: [Java, Race Condition, Threads, TreeMap, Red-Black Tree]
---


# Introduction

first fact 3200% CPU utilization. all cores full utilized.


open JDK has elapsed in thread dump

```
"Thread-0" #22 [14700] prio=5 os_prio=0 cpu=10359.38ms elapsed=11.49s tid=0x000001cdc35aaf60 nid=14700 runnable  [0x00000047cfffe000]
   java.lang.Thread.State: RUNNABLE
	at java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:826)
	at java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:534)
	at SimpleRepro.lambda$main$0(SimpleRepro.java:29)
	at SimpleRepro$$Lambda$14/0x00000008010031f0.run(Unknown Source)
	at java.lang.Thread.run(java.base@19.0.1/Thread.java:1589)
```

Red herring

```
public void someFunction(SomeType relatedObject, List<SomeOtherType> relatedObject) {
  for (SomeOtherType unrelatedObject : unrelatedObjects) {
    treeMap.put(relatedObject.a(), relatedObject.b());
  }
}
```

- talk about on further thought
  - the complexity of this loop is O(whatever)
  - etc

Aha moment
- browsing the rest of the class and notice that there are locks
- did we grab the lock before tree map?
- NO!!!

# Experiment

```java
threads.add(new Thread(() -> {
    Random random = new Random();
    for(int j = 0; j < numUpdates; j++) {
        try {
            treeMap.put(random.nextInt(1000), random.nextInt(1000));
        } catch (NullPointerException e) {
            // let it keep going so we can reproduce the issue.
        }
    }
}));
```
[from SimpleRepro.java](https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/src/main/SimpleRepro.java)

That's crazy! I always thought of race conditions as corrupting the data. I never though it could cause performance issues.


![example cycle generated from TreeMap experiment](/assets/2023-08-20_cpu_util_3200/red_black_tree_cycle.gv.svg)
[Complete code to generate above graph](https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/src/main/ExploringTreeMap.java)

# That code is not realistic

Is this code realistic? Who ignores NPEs?
Well we could reproduce this problem with in conjunction with another common bug that supresses uncaught exceptions.

## Uncaught Exceptions in Executor

The below code also reproduces the issue, but with a thread pool.
```java
final ExecutorService pool = Executors.newFixedThreadPool(numThreads);
final TreeMap<Integer,Integer> treeMap = new TreeMap<>();

Random random = new Random();
for (int i = 0; i < numThreads*numUpdatesPerThread; i++) {
    pool.submit( () -> {
        treeMap.put(random.nextInt(10000), random.nextInt(10000));
    });
}

pool.shutdown();
pool.awaitTermination(1, TimeUnit.DAYS);
```
[from ExecutorUncaughtRepro.java](https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/src/main/ExecutorUncaughtRepro.java)

When you run it, you'll see it hang. Take a thread dump and see the same symptoms:
```
"pool-1-thread-1" #22 [15356] prio=5 os_prio=0 cpu=17734.38ms elapsed=21.39s tid=0x0000023c45dd3e90 nid=15356 runnable  [0x000000780b4fe000]
   java.lang.Thread.State: RUNNABLE
	at java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:826)
	at java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:534)
	at ExecutorUncaughtRepro.lambda$main$0(ExecutorUncaughtRepro.java:33)
	at ExecutorUncaughtRepro$$Lambda$14/0x00000008010031f0.run(Unknown Source)
	at java.util.concurrent.Executors$RunnableAdapter.call(java.base@19.0.1/Executors.java:577)
	at java.util.concurrent.FutureTask.run(java.base@19.0.1/FutureTask.java:317)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@19.0.1/ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@19.0.1/ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(java.base@19.0.1/Thread.java:1589)

```
It's stuck on the TreeMap and really high CPU utilization.

However, when looking at standard out there is nothing! The threadpool swallowed all the NPEs not giving any indication of problem. Unfortunately, this was the case in my situation.

When managing your own threadpools you need to make sure you have an uncaught exception handler and also make sure to operate on the futures it return. If you do `future.get()` you will get an `ExectionException` wrapping the NPE!

## Again with gRPC

Nothing to standard out on server side.

```java
@Override
public void addReceipt(
    ReceiptProcessorServiceOuterClass.AddReceiptRequest req,
    StreamObserver<ReceiptProcessorServiceOuterClass.AddReceiptResponse> responseObserver
) {
    int timestamp = req.getTimestamp();
    int totalPrice = req.getTotalPrice();
    receipts.put(timestamp, totalPrice);
    ReceiptProcessorServiceOuterClass.AddReceiptResponse response = ReceiptProcessorServiceOuterClass.AddReceiptResponse.newBuilder().build();
    responseObserver.onNext(response);
    responseObserver.onCompleted();
}
```
[from GrpcRepro.java](https://github.com/josephmate/java-by-experiments/tree/main/tree_map_corruption/src/main/GrpcRepro.java)

```
"grpc-default-executor-23" #54 [8796] daemon prio=5 os_prio=0 cpu=18671.88ms elapsed=175.50s tid=0x00000168b6c707c0 nid=8796 runnable  [0x000000059fbfe000]
   java.lang.Thread.State: RUNNABLE
	at java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:826)
	at java.util.TreeMap.put(java.base@19.0.1/TreeMap.java:534)
	at ReceiptProcessorServiceImpl.addReceipt(GrpcRepro.java:59)
	at ReceiptProcessorServiceGrpc$MethodHandlers.invoke(ReceiptProcessorServiceGrpc.java:185)
	at io.grpc.stub.ServerCalls$UnaryServerCallHandler$UnaryServerCallListener.onHalfClose(ServerCalls.java:182)
	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.halfClosed(ServerCallImpl.java:346)
	at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1HalfClosed.runInContext(ServerImpl.java:860)
	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(java.base@19.0.1/ThreadPoolExecutor.java:1144)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(java.base@19.0.1/ThreadPoolExecutor.java:642)
	at java.lang.Thread.run(java.base@19.0.1/Thread.java:1589)
```

# Other languages

| Language   | Affected | Explanation | Code |
|------------|----------|-------------|------|
| Javscript  | no       | [multithreading model cannot share references](https://stackoverflow.com/questions/40028377/is-it-possible-to-achieve-multithreading-in-nodejs) | |
| Python     | no       | no red-black tree in standard libary and popular libraries like [Sorted Containers do not use red black tree](https://grantjenks.com/docs/sortedcontainers/implementation.html) |
| Typescript | no       | same argument as javascript|
| Java       | yes      | this whole article is based on this | TODO |
| C#         | yes      | [SortedDictionary](https://stackoverflow.com/questions/14909853/is-sorteddictionary-a-red-black-tree) used red black tree | TODO |
| C++        | maybe    | [used red-black tree](https://stackoverflow.com/questions/18414579/what-data-structure-is-inside-stdmap-in-c) but not sure how to get around seg fault | TODO |
| PHP        | no       | not in standard library and did not find any popular libraries   |
| Go         | maybe         | [has popular datastructures library](https://github.com/emirpasic/gods#redblacktree) but don't know enough about go's memory model. will it segfault or will it give an error I can ignore?     | TODO |
| Rust       |          | no red black tree. uses [BTree instead](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html). also ownership model prevents this sort of issue, unless you use unsafe     |
| Kotlin     | yes      | uses java's TreeMap     | TODO |
| Ruby       | maybe       | popular 3rd party library [kanwei/algorithms](http://kanwei.github.io/algorithms/classes/Containers/RubyRBTreeMap.html) uses red black tree     | TODO |

# How did it happen? Rotations

# How to fix easy

## Uncaught Exception Handler and Futures

## Alerts on error rates

## Alerts on utilization anomalies

## Gaurd against concurrent modification

# Controversial Fix

Modify the red-black tree to record the nodes it has already visited. The only requires an additional O(ln(n)) memory since it's limited by the height of the tree.

TODO code

# Conclusion

Mistakes happen. Wathc out, unprotected concurrent modification data corruption can present itself as infinite loops! As long as you have your monitoring in place you'll be able to respond quickly.
